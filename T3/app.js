$(document).ready(() => {
    const MAX_DIST_UNITS = 20;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let lines = [];
    let selectedLineIndex = -1;

    focus(); // FIX: A window.prompt() dialog generated by this page was suppressed because this page is not the active tab of the front window.
    let numSides = prompt("Digite um número entre 3 e 8 para gerar um polígono", "3");
    numSides = Math.max(3, Math.min(8, parseInt(numSides)));

    const getRandomRGB = () =>
        `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;

    const createPolygon = (numSides, { x, y }, radius) => {
        for (let i = 0; i < numSides; i++) {
            const angle = (2 * Math.PI * i) / numSides;
            const x1 = x + radius * Math.cos(angle);
            const y1 = y + radius * Math.sin(angle);
            const x2 = x + radius * Math.cos(angle + (2 * Math.PI) / numSides);
            const y2 = y + radius * Math.sin(angle + (2 * Math.PI) / numSides);
            lines.push({ x1, y1, x2, y2, rgb: getRandomRGB() });
        }
    };

    const drawLines = lines => 
        lines.forEach(({ rgb, x1, y1, x2, y2 }) => {
            ctx.strokeStyle = rgb;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        });

    const findLineIndex = (x, y) => {
        let nearestIndex = -1;
        let nearestDistance = Infinity;

        lines.forEach(({ x1, y1, x2, y2 }, index) => {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
            let distance;

            if (t >= 0 && t <= 1) {
                const closestX = x1 + t * dx;
                const closestY = y1 + t * dy;
                distance = Math.sqrt((closestX - x) ** 2 + (closestY - y) ** 2);
            } else { // If the closest point is outside the line segment, calculate the distance to the closest endpoint
                distance = Math.min(
                    Math.sqrt((x - x1) ** 2 + (y - y1) ** 2),
                    Math.sqrt((x - x2) ** 2 + (y - y2) ** 2)
                );
            }

            if (distance < nearestDistance && distance < MAX_DIST_UNITS) {
                nearestIndex = index;
                nearestDistance = distance;
            }
        });

        console.log(`Found line index: ${nearestIndex} (${nearestDistance} units)`);
        return nearestIndex;
    };

    createPolygon(numSides, { x: 400, y: 300 }, 200);
    drawLines(lines);

    canvas.addEventListener('mousedown', ({ clientX, clientY }) => {
        const { left, top } = canvas.getBoundingClientRect();
        const x = clientX - left;
        const y = clientY - top;

        selectedLineIndex = findLineIndex(x, y);
    });

    canvas.addEventListener('mouseup', () => {
        selectedLineIndex = -1;
    });

    canvas.addEventListener('mousemove', ({ clientX, clientY }) => {
        if (selectedLineIndex === -1) return;

        const { left, top } = canvas.getBoundingClientRect();
        const x = clientX - left;
        const y = clientY - top;

        lines.forEach(({ x1, y1, x2, y2 }, index) => {
            if (Math.abs(x - x1) < MAX_DIST_UNITS && Math.abs(y - y1) < MAX_DIST_UNITS) {
                lines[index].x1 = x;
                lines[index].y1 = y;
            } else if (Math.abs(x - x2) < MAX_DIST_UNITS && Math.abs(y - y2) < MAX_DIST_UNITS) {
                lines[index].x2 = x;
                lines[index].y2 = y;
            } else if (index === selectedLineIndex) {
                const dx = x - (x1 + x2) / 2;
                const dy = y - (y1 + y2) / 2;
                lines[index].x1 += dx;
                lines[index].y1 += dy;
                lines[index].x2 += dx;
                lines[index].y2 += dy;
            }
        });

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLines(lines);
    });

    canvas.addEventListener('contextmenu', e => {
        e.preventDefault();

        const { left, top } = canvas.getBoundingClientRect();
        const x = e.clientX - left;
        const y = e.clientY - top;

        selectedLineIndex = findLineIndex(x, y);
        const { x1, x2, y1, y2, rgb } = lines[selectedLineIndex];

        lines.splice(selectedLineIndex, 1, { x1, y1, x2: x, y2: y, rgb });
        lines.splice(selectedLineIndex + 1, 0, { x1: x, y1: y, x2, y2, rgb: getRandomRGB() });

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLines(lines);

        return false;
    });
});